import os
import csv
import requests
import logging
import asyncio
import unicodedata
import textwrap
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from flask import Flask
import threading
import time
import gspread
from oauth2client.service_account import ServiceAccountCredentials
import json

# üîπ Configura√ß√£o da autentica√ß√£o com Google Sheets
# Configura√ß√µes b√°sicas
TELEGRAM_TOKEN = '8109000267:AAFDXVsitaFwPFLSPul3iyfimpVeBMJ-4No'
GOOGLE_CREDENTIALS_JSON = json.loads(os.getenv("GOOGLE_CREDENTIALS_JSON"))
SCOPE = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
CREDENTIALS = ServiceAccountCredentials.from_json_keyfile_dict(GOOGLE_CREDENTIALS_JSON, SCOPE)
gc = gspread.authorize(CREDENTIALS)

# üîπ Fun√ß√£o para salvar nova escola na planilha
def salvar_escola_na_planilha(chat_id, nome, funcao, escola, telefone, email, endereco, localizacao):
    try:
        planilha = gc.open_by_url("https://docs.google.com/spreadsheets/d/115SXqaQ2T0xPzVQ9enFt4C-Ns1QOFBJfDSqKi1YaPKM")
        aba = planilha.worksheet("Escolas")  # Certifique-se de que a aba se chama "Escolas"

        # Adicionar nova escola na planilha
        aba.append_row([chat_id, nome, funcao, escola, telefone, email, endereco, localizacao])

        logging.info(f"‚úÖ Escola {escola} adicionada √† planilha com sucesso.")
        return True
    except Exception as e:
        logging.error(f"‚ùå Erro ao salvar escola na planilha: {e}")
        return False

# Inicializando Flask
app = Flask(__name__)

@app.route("/")
def home():
    return "Bot est√° ativo!"

# üîπ Configura√ß√£o de logs detalhados
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# üîπ Fun√ß√£o para iniciar o servidor Flask em uma thread separada
def iniciar_servidor():
    logging.info("üåê Iniciando o servidor Flask...")
    app.run(host="0.0.0.0", port=8080, debug=False, use_reloader=False)

# Fun√ß√£o para normalizar texto (remover acentos e deixar tudo mai√∫sculo)
def normalizar_texto(texto):
    return unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('utf-8').upper()

# Fun√ß√£o para carregar os dados diretamente do Google Sheets
def carregar_dados_csv():
    global dados_planilha, administradores
    try:
        # Conectar √† planilha do Google Sheets
        planilha = gc.open_by_url("https://docs.google.com/spreadsheets/d/115SXqaQ2T0xPzVQ9enFt4C-Ns1QOFBJfDSqKi1YaPKM")
        logging.info("‚úÖ Conectado √† planilha do Google Sheets")

        # Acessar as abas "Escolas" e "Administradores"
        aba_escolas = planilha.worksheet("Escolas")
        aba_admins = planilha.worksheet("Administradores")

        # Ler dados das escolas
        escolas = aba_escolas.get_all_values()
        cabecalho = escolas[0]  # Pega a primeira linha como refer√™ncia
        dados_planilha = [dict(zip(cabecalho, linha)) for linha in escolas[1:]]

        # Ler administradores
        administradores = [linha[0] for linha in aba_admins.get_all_values()[1:]]  # Pega a primeira coluna (Chat ID)

        logging.info("‚úÖ Dados da planilha carregados com sucesso.")

    except Exception as e:
        logging.error(f"‚ùå Erro ao carregar planilha: {e}")

# Fun√ß√£o para manter a planilha sempre atualizada
def atualizar_planilha_periodicamente():
    while True:
        carregar_dados_csv()
        time.sleep(300)  # Atualiza a cada 5 minutos

# Fun√ß√£o para buscar dados da escola pelo Chat ID
def buscar_dados_escola(chat_id):
    for linha in dados_planilha:
        if linha['Chat ID'] == str(chat_id):
            return linha
    return None

# Fun√ß√£o para obter administradores (busca na lista carregada)
def obter_administradores():
    return administradores  # Lista j√° carregada no carregar_dados_csv()

# Fun√ß√£o para exibir a mensagem de boas-vindas
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    mensagem_boas_vindas = (
        "üëã *Bem-vindo ao Guardi√£o Escolar!*\n\n"
        "Este Canal √© utilizado para comunica√ß√£o r√°pida e eficaz em situa√ß√µes de emerg√™ncia. "
        "Siga as instru√ß√µes abaixo para enviar alertas corretamente.\n\n"
        "‚ö†Ô∏è *Quando acionar?*\n"
        "- *Agressor Ativo*: Atos de viol√™ncia cont√≠nuos e deliberados contra a escola.\n"
        "- *Homic√≠dio ou Tentativa de Homic√≠dio*: Atos contra a vida.\n"
        "- *Tomada de Ref√©m*: Manter algu√©m sob amea√ßa para alcan√ßar algum objetivo.\n"
        "- *Amea√ßa de Explosivos*: Suspeita ou evid√™ncia de explosivo no per√≠metro escolar.\n\n"
        "üìã *Como enviar uma mensagem de emerg√™ncia?*\n"
        "1Ô∏è‚É£ *Inclua uma palavra-chave* na mensagem:\n"
        "- AGRESSOR\n- HOMIC√çDIO\n- REF√âM\n- BOMBA\n- TESTE DE ATIVA√á√ÉO\n"
        "2Ô∏è‚É£ *Envie os detalhes do ocorrido*, incluindo:\n"
        "- Localiza√ß√£o exata\n- N√∫mero de envolvidos\n- Estado das v√≠timas\n- Meios utilizados pelo agressor."
    )
    await update.message.reply_text(mensagem_boas_vindas, parse_mode='Markdown')


# Fun√ß√£o para exibir a ajuda
async def ajuda(update: Update, context: ContextTypes.DEFAULT_TYPE):
    mensagem_ajuda = (
        "üìã *Como usar o Guardi√£o Escolar:*\n\n"
        "1Ô∏è‚É£ *Envie uma mensagem contendo a palavra-chave*, seguida dos detalhes do ocorrido.\n"
        "2Ô∏è‚É£ *Inclua informa√ß√µes importantes*, como:\n"
        "- Localiza√ß√£o exata\n"
        "- N√∫mero de envolvidos\n"
        "- Estado das v√≠timas\n"
        "- Meios utilizados pelo agressor\n\n"
        "‚ö†Ô∏è *Importante*: Mantenha-se seguro e envie as informa√ß√µes apenas se isso n√£o colocar sua seguran√ßa em risco."
    )
    await update.message.reply_text(mensagem_ajuda, parse_mode='Markdown')

emergencia_ativa = False  # Controle de emerg√™ncia

# Fun√ß√£o para lidar com mensagens recebidas
async def mensagem_recebida(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global emergencia_ativa  # Controle de emerg√™ncia
    try:
        chat_id = str(update.message.chat_id)
        texto = update.message.text
        dados_escola = buscar_dados_escola(chat_id)

        # Verifica se o Chat ID est√° cadastrado na planilha
        if not dados_escola:
            # Enviar dados do usu√°rio para os administradores automaticamente
            mensagem_admin = (
                f"‚ö†Ô∏è *Novo usu√°rio tentando interagir com o bot!*\n\n"
                f"üìå *Chat ID*: `{chat_id}`\n"
                f"üë§ *Nome*: {update.message.from_user.first_name}\n"
                f"üîπ *Username*: @{update.message.from_user.username or 'Sem username'}\n\n"
                f"Para cadastr√°-lo, utilize:\n"
                f"`/cadastrar {chat_id};<Nome>;<Fun√ß√£o>;<Escola>;<Telefone>;<Email>;<Endere√ßo>;<Localiza√ß√£o>`"
            )

            for admin_id in obter_administradores():
                await context.bot.send_message(chat_id=admin_id, text=mensagem_admin, parse_mode='Markdown')

            # Se o usu√°rio digitou "CADASTRO", ele recebe uma mensagem informativa
            if texto.upper() == "CADASTRO":
                await update.message.reply_text(
                    "üìå Sua solicita√ß√£o foi enviada para an√°lise. Um administrador entrar√° em contato em breve.",
                    parse_mode='Markdown'
                )
            else:
                # Resposta padr√£o para usu√°rios n√£o cadastrados
                await update.message.reply_text(
                    "‚ö†Ô∏è *Canal exclusivo para as Institui√ß√µes de Ensino cadastradas.*\n"
                    "*Favor entrar em contato com o 190 em caso de emerg√™ncia.*\n"
                    "*Caso tenha interesse em se cadastrar, envie a mensagem \"CADASTRO\".*",
                    parse_mode='Markdown'
                )
            return  # Finaliza aqui para evitar processamento extra

        # üîπ Normaliza o texto recebido
        texto_normalizado = normalizar_texto(texto)

        palavra_chave_encontrada = False
        for palavra in ["AGRESSOR", "AGRESSORES", "HOMICIDIO", "REFEM", "REFENS", "BOMBA", "BOMBAS", "ATAQUE", "EXPLOS√ÉO", "TESTE"]:
            if palavra in texto_normalizado:
                palavra_chave_encontrada = True
                global emergencia_ativa
                emergencia_ativa = True  # Ativando emerg√™ncia

                # Enviar confirma√ß√£o para a escola que enviou a mensagem
                await update.message.reply_text(
                    "Mensagem Recebida, A Equipe do Guardi√£o Escolar est√° a Caminho."
                )

                # Preparar mensagem detalhada para os administradores
                mensagem_para_admins = (
                    f"‚ö†Ô∏è *Mensagem de emerg√™ncia recebida:*\n\n"
                    f"üè´ *Escola*: {dados_escola['Escola']}\n"
                    f"üë§ *Servidor*: {dados_escola['Nome']}\n"
                    f"üë§ *Fun√ß√£o*: {dados_escola['Fun√ß√£o']}\n"
                    f"üìû *Telefone*: {dados_escola['Telefone']}\n"
                    f"‚úâÔ∏è *Email*: {dados_escola['Email']}\n"
                    f"üìç *Endere√ßo*: {dados_escola['Endere√ßo']}\n"
                    f"üåê *Localiza√ß√£o*: {dados_escola['Localiza√ß√£o']}\n\n"
                    f"üì© *Mensagem original*: {texto}\n"
                    f"üë§ *Usu√°rio*: @{update.message.from_user.username or 'Sem username'} "
                    f"(Nome: {update.message.from_user.first_name}, Chat ID: {chat_id})"
                )

                # Enviar mensagem detalhada para cada administrador
                for admin_id in obter_administradores():
                    await context.bot.send_message(
                        chat_id=admin_id,
                        text=mensagem_para_admins,
                        parse_mode='Markdown'
                    )

                emergencia_ativa = False  # Finaliza a emerg√™ncia
                break

        if not palavra_chave_encontrada:
            mensagem_erro = (
                "‚ö†Ô∏è Este canal √© exclusivo para comunica√ß√£o de emerg√™ncias.\n\n"
                "Siga as orienta√ß√µes do menu /ajuda. Se voc√™ estiver em uma situa√ß√£o de emerg√™ncia, "
                "lembre-se de inserir a palavra-chave correspondente e incluir o m√°ximo de detalhes poss√≠vel.\n"
                "üìû Inclua tamb√©m um n√∫mero de contato para que possamos falar com voc√™."
            )
            await update.message.reply_text(mensagem_erro)

    except Exception:
        emergencia_ativa = False
        exibir_erro("Erro ao processar a mensagem recebida.")

# üîπ Fun√ß√£o para notificar administradores sobre um pedido de cadastro
async def notificar_admin_solicitacao_cadastro(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = str(update.message.from_user.id)
    first_name = update.message.from_user.first_name or "N√£o informado"
    username = f"@{update.message.from_user.username}" if update.message.from_user.username else "Sem username"

    mensagem = (
        f"üë§ *Novo pedido de cadastro*\n\n"
        f"üìå *Chat ID*: `{chat_id}`\n"
        f"üë§ *Nome*: {first_name}\n"
        f"üîπ *Username*: {username}\n\n"
        f"Para aprovar este usu√°rio, utilize o comando:\n"
        f"`/cadastrar {chat_id};<Nome>;<Fun√ß√£o>;<Escola>;<Telefone>;<Email>;<Endere√ßo>;<Localiza√ß√£o>`"
    )

    # üîπ Enviar para todos os administradores
    for admin_id in obter_administradores():
        await context.bot.send_message(chat_id=admin_id, text=mensagem, parse_mode='Markdown')

    # Confirma√ß√£o para o usu√°rio
    await update.message.reply_text("üìå Sua solicita√ß√£o foi enviada para an√°lise.")

# üîπ Fun√ß√£o para cadastrar um novo usu√°rio na planilha
async def cadastrar(update: Update, context: ContextTypes.DEFAULT_TYPE):
    administradores = obter_administradores()

    # üîπ Verifica se quem est√° cadastrando √© um administrador
    if str(update.message.chat_id) not in administradores:
        await update.message.reply_text("‚ö†Ô∏è Apenas administradores podem cadastrar novas escolas.")
        return

    # üîπ Captura e valida os dados enviados no comando
    dados = " ".join(context.args)
    campos = dados.split(";")

    if len(campos) != 8:
        await update.message.reply_text(
            "‚ö†Ô∏è *Formato inv√°lido!*\n\n"
            "Use o seguinte formato:\n"
            "`/cadastrar <ChatID>;<Nome>;<Fun√ß√£o>;<Escola>;<Telefone>;<Email>;<Endere√ßo>;<Localiza√ß√£o>`",
            parse_mode="Markdown"
        )
        return

    chat_id, nome, funcao, escola, telefone, email, endereco, localizacao = campos

    # üö® Bloquear cadastro duplicado
    if buscar_dados_escola(chat_id):
        await update.message.reply_text("‚ö†Ô∏è Esta escola j√° est√° cadastrada!")
        return

    # üîπ Adicionar a nova escola na planilha
    sucesso = adicionar_escola(chat_id, nome, funcao, escola, telefone, email, endereco, localizacao)

    if sucesso:
        await update.message.reply_text(f"‚úÖ *Escola {escola} cadastrada com sucesso!*", parse_mode="Markdown")
    else:
        await update.message.reply_text("‚ùå Erro ao salvar os dados na planilha.")

# üîπ Fun√ß√£o para adicionar uma nova escola √† mem√≥ria e salvar na planilha
def adicionar_escola(chat_id, nome, funcao, escola, telefone, email, endereco, localizacao):
    global dados_planilha
    try:
        nova_escola = {
            "Chat ID": chat_id,
            "Nome": nome,
            "Fun√ß√£o": funcao,
            "Escola": escola,
            "Telefone": telefone,
            "Email": email,
            "Endere√ßo": endereco,
            "Localiza√ß√£o": localizacao
        }
        dados_planilha.append(nova_escola)  # Adiciona localmente
        sucesso = salvar_escola_na_planilha(chat_id, nome, funcao, escola, telefone, email, endereco, localizacao)

        if sucesso:
            logging.info(f"‚úÖ Nova escola cadastrada e salva na planilha: {escola}")
            return True
        else:
            logging.error(f"‚ùå Erro ao salvar escola {escola} na planilha.")
            return False
    except Exception as e:
        logging.error(f"‚ùå Erro ao adicionar escola: {e}")
        return False

# üîπ Fun√ß√£o para listar todas as escolas cadastradas (apenas para administradores)
async def listar_escolas(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = str(update.message.chat_id)

    # üö® Verifica se o usu√°rio √© um administrador
    if chat_id not in obter_administradores():
        await update.message.reply_text("‚ö†Ô∏è Apenas administradores podem visualizar a lista de escolas cadastradas.")
        return

    # Verifica se h√° escolas cadastradas
    if not dados_planilha:
        await update.message.reply_text("üìå Nenhuma escola cadastrada ainda.")
        return

    # üîπ Monta a lista de escolas formatada
    mensagem = "üè´ *Lista de Escolas Cadastradas:*\n\n"
    for idx, escola in enumerate(dados_planilha, start=1):
        mensagem += f"{idx}. *{escola['Escola']}* - {escola['Nome']} ({escola['Fun√ß√£o']})\n"

    await update.message.reply_text(mensagem, parse_mode='Markdown')


# üîπ Fun√ß√£o para enviar alerta e tocar √°udio no Telegram
async def enviar_alerta(context: ContextTypes.DEFAULT_TYPE, dados_escola, tipo, detalhes):
    detalhes_quebrados = textwrap.fill(detalhes, width=80)

    mensagem = (
        f"üö® *ALERTA DE EMERG√äNCIA*\n\n"
        f"‚ö†Ô∏è *Tipo*: {tipo}\n"
        f"üè´ *Escola*: {dados_escola.get('Escola', 'N√£o informado')}\n"
        f"üë§ *Servidor*: {dados_escola.get('Nome', 'N√£o informado')}\n"
        f"üìû *Telefone*: {dados_escola.get('Telefone', 'N√£o informado')}\n"
        f"üìç *Localiza√ß√£o*: {dados_escola.get('Localiza√ß√£o', 'N√£o informado')}\n\n"
        f"üìù *Detalhes*: {detalhes_quebrados}"
    )

    arquivo_audio = "/mnt/data/teste.mp3" if tipo == "TESTE" else "/mnt/data/alerta.mp3"

    for admin_id in obter_administradores():
        try:
            await context.bot.send_message(chat_id=admin_id, text=mensagem, parse_mode='Markdown')

            with open(arquivo_audio, "rb") as audio:
                await context.bot.send_audio(chat_id=admin_id, audio=audio)

            logging.info(f"üö® Alerta ({tipo}) enviado para {admin_id} com √°udio.")
        except Exception as e:
            logging.error(f"‚ùå Erro ao enviar alerta para {admin_id}: {e}")

# üîπ Fun√ß√£o para rodar o Bot do Telegram corretamente (Ass√≠ncrono)
async def iniciar_bot():
    logging.info("ü§ñ Iniciando o bot do Telegram...")
    
    app_telegram = Application.builder().token(TELEGRAM_TOKEN).build()

    # üîπ Adicionar comandos ao bot
    app_telegram.add_handler(CommandHandler("start", start))
    app_telegram.add_handler(CommandHandler("ajuda", ajuda))
    app_telegram.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, mensagem_recebida))
    app_telegram.add_handler(CommandHandler("listarescolas", listar_escolas))

    # üîπ Iniciar atualiza√ß√£o autom√°tica da planilha
    threading.Thread(target=atualizar_planilha_periodicamente, daemon=True).start()

    # üîπ Iniciar o bot
    await app_telegram.run_polling()

# üîπ Configura√ß√£o principal do programa
async def main():
    # üîπ Carregar os dados da planilha antes de iniciar o bot
    carregar_dados_csv()

    # üîπ Iniciar o bot do Telegram
    await iniciar_bot()

if __name__ == "__main__":
    # üîπ Iniciar o servidor Flask em uma thread separada
    threading.Thread(target=iniciar_servidor, daemon=True).start()

    # üîπ Capturar o loop de eventos existente no Render
    loop = asyncio.get_event_loop()

    # üîπ Se o loop j√° estiver rodando (como no Render), cria uma task para rodar o bot sem travar
    if loop.is_running():
        logging.info("üîÑ Loop de eventos j√° est√° rodando, iniciando o bot como uma tarefa ass√≠ncrona...")
        loop.create_task(main())  # Usa `create_task()` para rodar sem conflitos
    else:
        logging.info("‚ñ∂Ô∏è Iniciando novo loop de eventos para o bot...")
        loop.run_until_complete(main())  # Para ambientes locais onde o loop n√£o est√° rodando
